////////////////////////////////////////////////////////////////////////////////
//! \file
//!
//! \author	Mauro Fiorentini
//!
//! \date	14/04/2018
//!
//! \par	Function:
//!	Contains the implementation of the data_structure_space::Vector class
//!	template.
//!
////////////////////////////////////////////////////////////////////////////////

namespace	data_structure_space
{

using	namespace	utility_space;

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Free the memory used to store the Vector. The object is left in a
//!	totally unknown state.
//!
//! \throw	None.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Free(void) noexcept
		{
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Store != static_cast<BASE_TYPE *>(NULL))
			delete [] Store;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Make a copy of the Vector passed as argument into current one. \n
//!	When the function is called, the object can be in an unknown state and
//!	its content is ignored.
//!
//! \param	thisVector			Reference to source Vector
//!						object.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::MakeCopy(const Vector& thisVector)
				throw(FatalException)
		{
		assert(thisVector.Size == 0 ||
			thisVector.Store != static_cast<BASE_TYPE *>(NULL));

		if ((Present = thisVector.Present) == 0)
			{
			Size = 0;
			Store = static_cast<BASE_TYPE *>(NULL);
			}
		else
			Copy(Store = new BASE_TYPE [Present], thisVector.Store,
				Size = Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Resize the Vector with default size growth: if the size is less than
//!	DEFAULT_VECTOR_SIZE, it is increased by DEFAULT_VECTOR_SIZE, otherwise
//!	it is multiplied for
//!	VECTOR_GROWTH_NUMERATOR / VECTOR_GROWTH_DENOMINATOR.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
//! \see	DEFAULT_VECTOR_SIZE
//! \see	VECTOR_GROWTH_NUMERATOR
//! \see	VECTOR_GROWTH_DENOMINATOR
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Grow(void) throw(FatalException)
		{
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		assert(Size <= STD_UINT_MAX / VECTOR_GROWTH_NUMERATOR);

		if (Size < DEFAULT_VECTOR_SIZE)
			Resize(Size + DEFAULT_VECTOR_SIZE);
		else
			Resize(Size * VECTOR_GROWTH_NUMERATOR /
				VECTOR_GROWTH_DENOMINATOR);
		assert(Size >= Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Copies the contents from the source array to the target array. \n
//!	No operation is performed if the number of elements to copy is zero.
//!	Target array and source array may overlap only if Target <= Source,
//!	otherwise the behaviour is undefined.
//!
//! \param	Target				Pointer to the target array.
//! \param	Source				Pointer to the source array.
//! \param	NumElements			Number of elements to copy.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
//! \note
//!	The utility_space::OUT_OF_MEMORY exception can be thrown only if
//!	generated by the assigment operator of BASE_TYPE.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Copy(register BASE_TYPE* Target,
				register const BASE_TYPE* Source,
				std_uint NumElements) noexcept
		{
		register	const	BASE_TYPE*	EndPointer;

		for (EndPointer = Source + NumElements; Source < EndPointer;)
			*Target++ = *Source++;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Return a pointer to the array of elements. \n
//!	The pointer is intended for immediate use and shall not be stored, as
//!	it will be no longer valid after most operations on the Vector.
//!
//! \throw	None.
//!
//! \returns	BASE_TYPE*	Pointer to the array of elements.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	BASE_TYPE*	Vector<BASE_TYPE>::GetStore(void) noexcept
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		return Store;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Return a constant pointer to the array of elements. \n
//!	The pointer is intended for immediate use and shall not be stored, as
//!	it will be no longer valid after most operations on the Vector.
//!
//! \throw	None.
//!
//! \returns	BASE_TYPE*	Pointer to the array of elements.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	const	BASE_TYPE*	Vector<BASE_TYPE>::GetStore(void) const
						noexcept
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		return Store;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Set the number of elements.
//!
//! \param	thisPresent			Number of elements in the array.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::SetPresent(std_uint thisPresent)
				throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (thisPresent > Size)
			Resize(thisPresent);
		Present = thisPresent;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Default constructor; construct a Vector object with DEFAULT_VECTOR_SIZE
//!	elements.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	Not applicable.
//!
//! \see	DEFAULT_VECTOR_SIZE
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::Vector(void) throw(FatalException):
			Store(new BASE_TYPE [DEFAULT_VECTOR_SIZE]),
			Size(DEFAULT_VECTOR_SIZE), Present(0)
		{
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Single argument constructor; construct a Vector object with the size
//!	passed as argument.
//!
//! \param	thisSize			Size of the Vector.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	Not applicable.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::Vector(std_uint thisSize)
			throw(FatalException):
			Store(static_cast<BASE_TYPE *>(NULL)), Size(thisSize),
			Present(0)
		{
		if (Size != 0)
			Store = new BASE_TYPE [Size];
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Constructor; construct a Vector object with the specified size and
//!	initialize all elements with the given value.
//!
//! \param	Value				Value to be copied into all
//!						elements of the Vector.
//! \param	thisSize			Size of the Vector.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	Not applicable.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::Vector(const BASE_TYPE& Value,
			std_uint thisSize) throw(FatalException):
			Store(static_cast<BASE_TYPE *>(NULL)), Size(thisSize),
			Present(thisSize)
		{
		if (Size != 0)
			{
			Store = new BASE_TYPE [Size];
			ReplaceAll(Value);
			}
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Construct a new Vector, copying a specified number of elements from an
//!	existing object, starting from a specified index. \n
//!	The Vector argument must be different from the object itself. \n
//!	An attempt to copy zero elements from the beginning of an empty Vector
//!	does nothing. \n
//!	An attempt to copy zero elements from an index different from zero from
//!	an empty Vector throws an exception.
//!
//! \param	thisVector				Reference to source
//!							Vector object.
//! \param	StartIndex				Starting index of the
//!							source Vector. Valid
//!							range is
//!					[0 .. thisVector.GetPresent() - 1].
//! \param	NumElements				Number of elements to be
//!							copied from the source
//!							Vector. Valid range is
//!					[0 .. thisVector.GetPresent()].
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::ILLEGAL_ARGUMENT		If the Vector argument
//!							is the object itself.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If the function attempts
//!							to read an element of
//!							the source Vector with
//!							invalid index.
//!
//! \returns	Not applicable
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::Vector(const Vector& thisVector,
			std_uint StartIndex, std_uint NumElements)
			throw(FatalException):
			Store(static_cast<BASE_TYPE *>(NULL)),
			Size(NumElements), Present(NumElements)
		{
		if (this == &thisVector)
			throw make_fatal_exception(ILLEGAL_ARGUMENT);
		if (StartIndex + NumElements > 0)
			{
			if (StartIndex >= thisVector.GetPresent())
				throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
			if (StartIndex + NumElements > thisVector.GetPresent())
				throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
			}
		if (Size != 0)
			{
			Store = new BASE_TYPE [Size];
			Copy(Store, thisVector.Store + StartIndex, NumElements);
			}

		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		assert(Size >= Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Copy constructor. \n
//!	The Vector argument must be different from the object itself.
//!
//! \param	thisVector			Reference to source Vector
//!						object.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//! \throw	utility_space::ILLEGAL_ARGUMENT	If the Vector argument is the
//!						object itself.
//!
//! \returns	Not applicable.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::Vector(const Vector& thisVector)
			throw(FatalException):
			Store(static_cast<BASE_TYPE *>(NULL)), Size(0),
			Present(0)
		{
		assert(thisVector.Size >= thisVector.Present);
		assert(thisVector.Size == 0 ||
			thisVector.Store != static_cast<BASE_TYPE *>(NULL));

		if (this == &thisVector)
			throw make_fatal_exception(ILLEGAL_ARGUMENT);
		MakeCopy(thisVector);

		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Move constructor. \n
//!	The Vector argument must be different from the object itself.
//!
//! \param	thisVector			Reference to source Vector
//!						object.
//!
//! \throw	utility_space::ILLEGAL_ARGUMENT	If the Vector argument is the
//!						object itself.
//!
//! \returns	Not applicable.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::Vector(Vector&& thisVector)
			throw(FatalException): Store(thisVector.Store),
			Size(thisVector.Size), Present(thisVector.Present)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (this == &thisVector)
			throw make_fatal_exception(ILLEGAL_ARGUMENT);
		thisVector.Store = static_cast<BASE_TYPE *>(NULL);
		thisVector.Size = thisVector.Present = 0;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Destructor. Free the memory used by the Vector.
//!
//! \throw	None.
//!
//! \returns	Not applicable.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>::~Vector(void) noexcept
		{
		Free();
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Assignment operator.
//!
//! \param	thisVector			Reference to source Vector
//!						object.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	const	Vector<BASE_TYPE>&	Reference to the assigned Vector
//!						object.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>&	Vector<BASE_TYPE>::operator = (const
						Vector& thisVector)
						throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		assert(thisVector.Size >= thisVector.Present);
		assert(thisVector.Size == 0 ||
			thisVector.Store != static_cast<BASE_TYPE *>(NULL));

		if (this != &thisVector)
			if (thisVector.Present > Size)
				{
				Free();
				MakeCopy(thisVector);
				}
			else
				if ((Present = thisVector.Present) == 0)
					{
					Free();
					Size = 0;
					Store = static_cast<BASE_TYPE *>(NULL);
					}
				else
					Copy(Store, thisVector.Store, Present);
		return *this;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Move assignment operator.
//!
//! \param	thisVector			Reference to source Vector
//!						object.
//!
//! \throw	None.
//!
//! \returns	const	Vector<BASE_TYPE>&	Reference to the assigned Vector
//!						object.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	Vector<BASE_TYPE>&	Vector<BASE_TYPE>::operator = (Vector&&
						thisVector) noexcept
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		assert(thisVector.Size >= thisVector.Present);
		assert(thisVector.Size == 0 ||
			thisVector.Store != static_cast<BASE_TYPE *>(NULL));

		if (this != &thisVector)
			{
			Store = thisVector.Store;
			Size = thisVector.Size;
			Present = thisVector.Present;
			thisVector.Store = static_cast<BASE_TYPE *>(NULL);
			thisVector.Size = thisVector.Present = 0;
			}
		return *this;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Subscript operator, used to get access to the elements of a Vector.
//!
//! \param	Index					Index of the element to
//!							be retrieved. Valid
//!							range is
//!							[0 .. GetPresent() - 1].
//!
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If the index is not less
//!							than the number of
//!							contained objects.
//!
//! \returns	BASE_TYPE&				Reference to the
//!							selected element.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	BASE_TYPE&	Vector<BASE_TYPE>::operator [] (std_uint Index)
					throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Index >= Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
		return Store [Index];
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Subscript operator, used to get access to the elements of a Vector.
//!
//! \param	Index					Index of the element to
//!							be retrieved. Valid
//!							range is
//!							[0 .. GetPresent() - 1].
//!
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If the index is not less
//!							than the number of
//!							contained objects.
//!
//! \returns	const	BASE_TYPE&			Reference to the
//!							selected element.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	const	BASE_TYPE&	Vector<BASE_TYPE>::operator [] (std_uint
						Index) const
						throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Index >= Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
		return Store [Index];
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Return the number of allocated elements in the Vector.
//!
//! \throw	None.
//!
//! \returns	std_uint	Number of allocated elements in the Vector.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	std_uint	Vector<BASE_TYPE>::GetSize(void) const noexcept
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		return Size;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Return the number of items currently stored in the Vector.
//!
//! \throw	None.
//!
//! \returns	std_uint	Number of items currently stored in the Vector.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	std_uint	Vector<BASE_TYPE>::GetPresent(void) const
					noexcept
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		return Present;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Check whether the Vector is currently empty.
//!
//! \throw	None.
//!
//! \returns	bool	True if the Vector is currently empty.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	bool	Vector<BASE_TYPE>::IsEmpty(void) const noexcept
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		return Present == 0;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Delete all elements from the Vector.
//!
//! \throw	None.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Clear(void) noexcept
		{
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		Present = 0;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Append an element of type BASE_TYPE to the Vector.
//!
//! \param	Value				Reference to the element to be
//!						appended.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Append(const BASE_TYPE& Value)
				throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Present == Size)
			Grow();
		assert(Size > Present);
		Store [Present++] = Value;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Append copies of an element, a given number of times.
//!
//! \param	Value				Reference to the element to be
//!						appended.
//! \param	NumCopies			Number of copies; if it is zero,
//!						no operation is performed.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Append(const BASE_TYPE& Value,
				std_uint NumCopies) throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		Insert(Value, Present, NumCopies);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Append all elements from the source Vector to the current Vector. \n
//!	Appending an empty Vector does nothing. \n
//!	The Vector argument must be different from the object itself.
//!
//! \param	thisVector			Reference to source Vector
//!						object.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//! \throw	utility_space::ILLEGAL_ARGUMENT	If the Vector argument is the
//!						object itself.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Append(const Vector& thisVector)
				throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		assert(thisVector.Size >= thisVector.Present);
		assert(thisVector.Size == 0 ||
			thisVector.Store != static_cast<BASE_TYPE *>(NULL));

		Append(thisVector, 0, thisVector.Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Append a part of the source Vector to the current Vector. \n
//!	An attempt to append zero elements from the beginning of an empty Vector
//!	does nothing. \n
//!	An attempt to append zero elements from an index different from zero
//!	from an empty Vector throws an exception. \n
//!	The Vector argument must be different from the object itself.
//!
//! \param	thisVector				Reference to source
//!							Vector object.
//! \param	StartIndex				Starting index of the
//!							appended Vector. Valid
//!							range is
//!					[0 .. thisVector.GetPresent() - 1].
//! \param	NumElements				Number of elements to be
//!							copied from the source
//!							Vector. Valid range is
//!					[0 .. thisVector.GetPresent()].
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::ILLEGAL_ARGUMENT		If the Vector argument
//!							is the object itself.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If the function attempts
//!							to read an element of
//!							the source Vector with
//!							invalid index.
//!
//! \returns	None
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Append(const Vector& thisVector,
				std_uint StartIndex, std_uint NumElements)
				throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));
		assert(thisVector.Size >= thisVector.Present);
		assert(thisVector.Size == 0 ||
			thisVector.Store != static_cast<BASE_TYPE *>(NULL));

		if (this == &thisVector)
			throw make_fatal_exception(ILLEGAL_ARGUMENT);
		if (StartIndex + NumElements == 0)
			return;
		if (StartIndex >= thisVector.GetPresent())
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
		if (StartIndex + NumElements > thisVector.GetPresent())
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);

			// If thisVector.Present is 0, previous tests
			// guarantees that StartIndex and NumElements are 0 too,
			// so it is not necessary to test them again
		if (NumElements == 0)
			return;

		if (Size < Present + NumElements)
			Resize(Present + NumElements);

		assert(Size >= Present + NumElements);

		Copy(Store + Present, thisVector.Store + StartIndex,
			NumElements);
		Present += NumElements;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Overwrite an element with another passed as argument.
//!
//! \param	Value					Reference to the new
//!							value.
//! \param	Index					Index of the element to
//!							be replaced. Valid range
//!							is
//!							[0 .. GetPresent() - 1].
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If the index is not less
//!							than the number of
//!							contained objects.
//!
//! \returns	None.
//!
//! \note
//!	The utility_space::OUT_OF_MEMORY exception can be thrown only if
//!	generated by the assigment operator of BASE_TYPE.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Replace(const BASE_TYPE& Value,
				std_uint Index) throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Index >= Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
		Store [Index] = Value;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Insert a given element, in a given position.
//!
//! \param	Value					Reference to the value
//!							to be inserted.
//! \param	Index					The index from which the
//!							elements shall be
//!							inserted. Valid range is
//!							[0 .. GetPresent()].
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If StartIndex is greater
//!							than the number of
//!							present elements.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Insert(register const BASE_TYPE&
				Value, register std_uint Index)
				throw(FatalException)
		{
		register	std_uint	i;

		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Index > Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);

		if (Size < Present + 1)
			Grow();

			// Shift elements to the right to free NumCopies places
		for (i = 0; i < Present - Index; ++i)
			Store [Present - i] = Store [Present - 1 - i];

			// Insert the new element.
		Store [Index] = Value;
		++Present;

		assert(Size >= Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Insert copies of the given element, starting from a given index, a given
//!	number of times.
//!
//! \param	Value					Reference to the value
//!							to be inserted.
//! \param	StartIndex				The index from which the
//!							elements shall be
//!							inserted. Valid range is
//!							[0 .. GetPresent()].
//! \param	NumCopies				Number of copies; if it
//!							is zero, no operation is
//!							performed.
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::ILLEGAL_ARGUMENT		If the number of copies
//!							is greater than
//!							MAX_ADDED_COPIES.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If StartIndex is greater
//!							than the number of
//!							present elements.
//!
//! \returns	None.
//!
//! \see	MAX_ADDED_COPIES
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Insert(register const BASE_TYPE&
				Value, register std_uint StartIndex,
				register std_uint NumCopies)
				throw(FatalException)
		{
		register	std_uint	i;

		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (StartIndex > Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);

			// No element need to be inserted.
		if (NumCopies == 0)
			return;

		if (NumCopies > MAX_ADDED_COPIES)
			throw make_fatal_exception(ILLEGAL_ARGUMENT);

		if (Size < Present + NumCopies)
			Resize(Present + (NumCopies >= DEFAULT_VECTOR_SIZE?
				NumCopies: DEFAULT_VECTOR_SIZE));

			// Shift elements to the right to free NumCopies places.
		for (i = 0; i < Present - StartIndex; ++i)
			Store [Present + NumCopies - 1 - i] =
				Store [Present - 1 - i];

			// Insert copies of the new element.
		for (i = StartIndex; i < StartIndex + NumCopies; ++i)
			Store [i] = Value;
		Present += NumCopies;

		assert(Size >= Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Remove a specified number of elements from the end.
//!
//! \param	NumElements				Number of elements to be
//!							removed. Valid range is
//!							[0 .. GetPresent()].
//!
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If NumElements is
//!							greater than the number
//!							of present elements.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::RemoveRear(std_uint NumElements)
				throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (NumElements > Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);

		Present -= NumElements;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Remove an element at a given index.
//!
//! \param	StartIndex				Index from which the
//!							element shall be
//!							removed. Valid range is
//!							[0 .. GetPresent() - 1].
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If StartIndex is not
//!							less than the number of
//!							elements in the object.
//!
//! \returns	None.
//!
//! \note
//!	The utility_space::OUT_OF_MEMORY exception can be thrown only if
//!	generated by the default constructor of BASE_TYPE.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Remove(std_uint StartIndex)
				throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (StartIndex >= Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
		Copy(Store + StartIndex, Store + StartIndex + 1,
			Present - StartIndex - 1);
		--Present;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Remove a specified number of elements, starting from a given index. \n
//!	An attempt to remove zero elements from the beginning of an empty Vector
//!	does nothing.
//!
//! \param	StartIndex				Index from which the
//!							elements shall be
//!							removed. Valid range is
//!							[0 .. GetPresent() - 1].
//! \param	NumElements				Number of elements to be
//!							removed. Valid range is
//!							[0 .. GetPresent()].
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If StartIndex is not
//!							less than the number of
//!							elements in the object
//!							or StartIndex plus
//!							NumElements is greater
//!							than the number of
//!							elements.
//!
//! \returns	None.
//!
//! \note
//!	The utility_space::OUT_OF_MEMORY exception can be thrown only if
//!	generated by the assigment operator of BASE_TYPE.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Remove(std_uint StartIndex,
				std_uint NumElements) throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (StartIndex >= Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);
		if (StartIndex + NumElements > Present)
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);

		Copy(Store + StartIndex, Store + StartIndex + NumElements,
			Present - StartIndex - NumElements);
		Present -= NumElements;
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Resize the Vector to NewSize.
//!
//! \param	NewSize					New size of the Vector;
//!							if it is zero and the
//!							Vector is empty, the
//!							memory is freed.
//!
//! \throw	utility_space::OUT_OF_MEMORY		If memory allocation
//!							fails.
//! \throw	utility_space::INDEX_OUT_OF_BOUNDS	If NewSize is less than
//!							the number of present
//!							elements.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Resize(std_uint NewSize)
				throw(FatalException)
		{
		BASE_TYPE*	p;

		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (NewSize < GetPresent())
			throw make_fatal_exception(INDEX_OUT_OF_BOUNDS);

		if (NewSize == Size)
			return;
		if (NewSize == 0)
			{
			Free();
			Store = static_cast<BASE_TYPE *>(NULL);
			}
		else
			{
			Copy(p = new BASE_TYPE [NewSize], Store, Present);
			Free();
			Store = p;
			}
		Size = NewSize;
		assert(Size >= Present);
		}

////////////////////////////////////////////////////////////////////////////////
//! \par	Description:
//!	Reduce the allocated storage to the minimum possible size.
//!
//! \throw	utility_space::OUT_OF_MEMORY	If memory allocation fails.
//!
//! \returns	None.
//!
////////////////////////////////////////////////////////////////////////////////

template<class BASE_TYPE>
	INLINE	void	Vector<BASE_TYPE>::Trim(void) throw(FatalException)
		{
		assert(Size >= Present);
		assert(Size == 0 || Store != static_cast<BASE_TYPE *>(NULL));

		if (Present == 0)
			{
			Free();
			Size = 0;
			Store = static_cast<BASE_TYPE *>(NULL);
			}
		else
			Resize(Present);
		}

}
